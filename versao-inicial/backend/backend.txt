O QUE Ã‰ O CORS?

CORS (Cross-Origin Resource Sharing) Ã© um mecanismo de seguranÃ§a implementado nos navegadores para
controlar como os recursos de uma pÃ¡gina da web podem ser acessados por outra origem (domÃ­nio, protocolo
ou porta). Isso Ã© relevante principalmente quando vocÃª estÃ¡ fazendo requisiÃ§Ãµes entre diferentes
domÃ­nios, o que Ã© comum em APIs e aplicaÃ§Ãµes web modernas.

No contexto de **Node.js**, o CORS se refere Ã  configuraÃ§Ã£o de permissÃµes para permitir ou bloquear o
acesso a recursos da sua aplicaÃ§Ã£o a partir de origens externas.

Por exemplo, se o seu servidor Node.js estiver servindo uma API, e vocÃª quiser permitir que essa API
seja acessada de um frontend hospedado em outro domÃ­nio (ex: frontend em `https://meuapp.com` e
backend em `https://api.meuapp.com`), vocÃª precisarÃ¡ configurar o CORS para que o navegador permita
essa interaÃ§Ã£o.

Em Node.js, Ã© comum usar o **middleware `cors`** para lidar com isso. O `cors` Ã© um pacote que
simplifica a configuraÃ§Ã£o do CORS.

### Exemplo de como configurar CORS com o pacote `cors` no Node.js:

1. Primeiro, instale o pacote:

   ```bash
   npm install cors
   ```

2. Depois, configure o middleware no seu cÃ³digo:

   ```javascript
   const express = require('express');
   const cors = require('cors');

   const app = express();

   // Permitir todas as origens
   app.use(cors());

   // Ou configurar para permitir uma origem especÃ­fica:
   app.use(cors({
     origin: 'https://meuapp.com'
   }));

   app.get('/', (req, res) => {
     res.send('API funcionando com CORS!');
   });

   app.listen(3000, () => {
     console.log('Servidor rodando na porta 3000');
   });
   ```

No exemplo acima, o servidor Express permite que qualquer origem acesse os recursos da API, ou, se
configurado com uma origem especÃ­fica, sÃ³ a partir dessa origem o acesso serÃ¡ permitido.

### Como o CORS funciona?
Quando o navegador faz uma requisiÃ§Ã£o a uma origem diferente da atual (cross-origin), ele inclui um
cabeÃ§alho chamado `Origin`. O servidor entÃ£o verifica se a origem da requisiÃ§Ã£o Ã© permitida e responde 
com os cabeÃ§alhos CORS adequados (como `Access-Control-Allow-Origin`), informando ao navegador se ele
pode ou nÃ£o permitir o acesso.

Se a origem for permitida, o navegador deixa a requisiÃ§Ã£o ser concluÃ­da; caso contrÃ¡rio, ele bloqueia
a requisiÃ§Ã£o e, normalmente, exibe um erro no console.


NÃ³s temos duas aplicaÃ§Ãµes, o backend e o frontend, uma aplicaÃ§Ã£o, que Ã© o backend,
ela precisa do node, isso tanto em um ambiente de desenvolvimento tanto de
produÃ§Ã£o, ela roda em cima do node, pois ela usa a API do node, por outro lado, a nossa aplicaÃ§Ã£o frontend nÃ£o
precisa do node em ambiente de produÃ§Ã£o, pois o build gerado durante o desenvolvimento
Ã© de arquivos estÃ¡ticos, nomeadamente HTML,CSS,JAVASCRIPT, IMAGEM, FONTE, tudo isso
sÃ£o arquivos estÃ¡ticos que podem ser executados em um servidor Apache, ngnix, na
Amazon(S3) que Ã© um repositÃ³rio de arquivos estÃ¡ticos, como um site feito em Vue.js,
React, desse modo, nÃ£o hÃ¡ necessidade de configurar a sua aplicaÃ§Ã£o frontend usando
o node para a produÃ§Ã£o apenas para o desenvolvimento, por conta dos pacotes que
serÃ£o instalados, como o Create-React-App, o vue-cli.


AUTHSECRET,TOKEN, JWT:

O `authSecret` em um arquivo `.env` dentro de uma aplicaÃ§Ã£o Node.js normalmente
se refere a uma chave secreta utilizada para autenticaÃ§Ã£o ou assinatura de tokens,
como JSON Web Tokens (JWT), por exemplo. Essa chave Ã© crucial para garantir a
seguranÃ§a do processo de autenticaÃ§Ã£o e autorizaÃ§Ã£o na aplicaÃ§Ã£o.

### Usos comuns do `authSecret`:

1. **Assinatura de JWT**: Quando vocÃª utiliza JWT para autenticar usuÃ¡rios, 
o `authSecret` Ã© utilizado para assinar o token. Esse token Ã© entÃ£o enviado ao
cliente (geralmente no cabeÃ§alho de requisiÃ§Ã£o) e, quando o servidor recebe o
token novamente, ele pode usar a chave secreta para verificar se o token nÃ£o foi
alterado.

   Exemplo:
   ```javascript
   const jwt = require('jsonwebtoken');
   const secretKey = process.env.authSecret;

   // Criando o token
   const token = jwt.sign({ userId: 1 }, secretKey, { expiresIn: '1h' });

   // Verificando o token
   jwt.verify(token, secretKey, (err, decoded) => {
     if (err) {
       return res.status(401).send('Token invÃ¡lido');
     }
     res.send('Token vÃ¡lido');
   });
   ```

2. **SeguranÃ§a**: A chave secreta (`authSecret`) deve ser mantida em segredo, ou
seja, ela **nÃ£o deve ser compartilhada publicamente**. Ã‰ por isso que, normalmente,
ela Ã© armazenada em um arquivo `.env` para que nÃ£o fique exposta no cÃ³digo fonte. 
No arquivo `.env`, ela pode ser definida da seguinte forma:

   ```env
   authSecret=MinhaChaveSuperSecreta
   ```

3. **Evitar Hardcoding**: A utilizaÃ§Ã£o do `.env` permite evitar o hardcoding de
segredos diretamente no cÃ³digo-fonte, o que ajuda a melhorar a seguranÃ§a e
facilita a alteraÃ§Ã£o dessa chave sem necessidade de modificar o cÃ³digo da
aplicaÃ§Ã£o.

### Exemplo de uso do `.env` com `authSecret`:

Arquivo `.env`:
```env
authSecret=MinhaChaveSuperSecreta
```

No cÃ³digo Node.js:
```javascript
require('dotenv').config();
const jwt = require('jsonwebtoken');

// Recuperando a chave secreta do .env
const secretKey = process.env.authSecret;

// Gerando um token
const token = jwt.sign({ userId: 1 }, secretKey, { expiresIn: '1h' });

console.log(token);
```

### Resumo:
O `authSecret` Ã© uma chave usada para garantir a seguranÃ§a nas operaÃ§Ãµes de
autenticaÃ§Ã£o, como a assinatura de tokens JWT. Ele deve ser mantido em um local
seguro (como o arquivo `.env`) e nunca ser exposto no cÃ³digo-fonte da aplicaÃ§Ã£o.


Assinar um token JWT (JSON Web Token) significa aplicar uma assinatura digital ao
token, que garante sua integridade e autenticidade. A assinatura permite que o
servidor ou a aplicaÃ§Ã£o verifique se o conteÃºdo do token nÃ£o foi alterado durante
a transmissÃ£o e se ele foi realmente emitido por uma fonte confiÃ¡vel (o servidor
ou o serviÃ§o que o gerou).

### O que compÃµe um token JWT?

Um token JWT Ã© composto por trÃªs partes:

1. **Header (CabeÃ§alho)**: ContÃ©m informaÃ§Ãµes sobre o algoritmo de assinatura
   utilizado (geralmente `HS256`, `RS256` etc.).
   Exemplo de cabeÃ§alho:
   ```json
   {
     "alg": "HS256",
     "typ": "JWT"
   }
   ```

2. **Payload (Corpo)**: ContÃ©m as informaÃ§Ãµes que vocÃª deseja transportar
   (como o ID do usuÃ¡rio, permissÃµes, etc.). Esse conteÃºdo pode ser lido por
   qualquer pessoa que tenha o token, mas nÃ£o pode ser alterado sem invalidar a
   assinatura.
   Exemplo de payload:
   ```json
   {
     "sub": "1234567890",
     "name": "JoÃ£o Silva",
     "iat": 1516239022
   }
   ```

3. **Signature (Assinatura)**: A parte mais importante. A assinatura Ã© criada
utilizando o algoritmo especificado no cabeÃ§alho e uma chave secreta (ou um par
de chaves pÃºblica/privada, dependendo do algoritmo). Essa assinatura garante que
o token nÃ£o foi alterado depois de sua criaÃ§Ã£o.

### Como funciona a assinatura?

Quando vocÃª cria um JWT, vocÃª usa a chave secreta (no caso de algoritmos
simÃ©tricos, como o `HS256`) ou um par de chaves (em algoritmos assimÃ©tricos, como
 o `RS256`) para gerar a assinatura. O processo de assinatura pode ser explicado
da seguinte forma:

1. O cabeÃ§alho e o corpo do token (payload) sÃ£o convertidos para o formato JSON e,
em seguida, codificados em Base64Url.

2. Uma string formada pela combinaÃ§Ã£o do cabeÃ§alho e do payload codificados Ã©
entÃ£o assinada utilizando a chave secreta ou a chave privada, dependendo do
algoritmo.

3. A assinatura gerada Ã© entÃ£o concatenada com o cabeÃ§alho e o payload, formando
o token JWT final.

### Exemplo de como a assinatura funciona:

Vamos imaginar que vocÃª tenha a seguinte informaÃ§Ã£o no cabeÃ§alho e payload:

**CabeÃ§alho**:
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

**Payload**:
```json
{
  "sub": "1234567890",
  "name": "JoÃ£o Silva",
  "iat": 1516239022
}
```

O processo de assinatura seria o seguinte:

1. O cabeÃ§alho e o payload sÃ£o codificados em Base64Url:
   - CabeÃ§alho codificado: `eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9`
   - Payload codificado: `eyJzdWIiOiAiMTIzNDU2Nzg5MCIsICJuYW1lIjogIkpvw6NvbyBMaW92YSIsICJpYXQiOiAiMTUxNjIzOTAyMiJ9`

2. A string combinada do cabeÃ§alho e payload fica assim:
   ```text
   eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJzdWIiOiAiMTIzNDU2Nzg5MCIsICJuYW1lIjogIkpvw6NvbyBMaW92YSIsICJpYXQiOiAiMTUxNjIzOTAyMiJ9
   ```

3. A assinatura Ã© gerada utilizando a chave secreta (vamos chamar de `MinhaChaveSecreta`) e o algoritmo `HS256`. O resultado seria algo assim (gerado de forma criptogrÃ¡fica):
   ```text
   hRrD0VuS9tYdoq1J78Qwv5YZ4G6wEwHbgqk4Wx9e8do
   ```

4. O token JWT final ficaria assim:
   ```text
   eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJzdWIiOiAiMTIzNDU2Nzg5MCIsICJuYW1lIjogIkpvw6NvbyBMaW92YSIsICJpYXQiOiAiMTUxNjIzOTAyMiJ9.hRrD0VuS9tYdoq1J78Qwv5YZ4G6wEwHbgqk4Wx9e8do
   ```

### Como a assinatura garante a seguranÃ§a?

- **Integridade**: Como o token Ã© assinado com uma chave secreta ou chave privada,
qualquer alteraÃ§Ã£o no conteÃºdo do cabeÃ§alho ou payload (mesmo uma vÃ­rgula ou
espaÃ§o) vai invalidar a assinatura. Ao verificar a assinatura no servidor, vocÃª
pode garantir que o conteÃºdo nÃ£o foi alterado.
  
- **Autenticidade**: A assinatura permite verificar que o token foi realmente
emitido por uma fonte confiÃ¡vel, jÃ¡ que apenas quem tem a chave secreta ou chave
privada pode criar ou validar essa assinatura.

### VerificaÃ§Ã£o da assinatura:

Quando o servidor recebe um JWT, ele pode verificar a assinatura utilizando a
chave secreta (no caso do algoritmo simÃ©trico) ou a chave pÃºblica (no caso do
algoritmo assimÃ©trico) para garantir que o token nÃ£o foi modificado.

Se o servidor calcular a assinatura do token com a chave correta e ela
corresponder Ã  assinatura que acompanha o token, entÃ£o o token Ã© vÃ¡lido. Caso
contrÃ¡rio, ele Ã© rejeitado.

### Resumo:

Assinar um token JWT significa aplicar uma assinatura digital ao token, usando
uma chave secreta ou uma chave privada. Essa assinatura garante que o token nÃ£o
foi alterado durante o trÃ¡fego de rede e que ele foi emitido por uma fonte
confiÃ¡vel, permitindo a autenticaÃ§Ã£o e a verificaÃ§Ã£o da integridade dos dados do
token.


Um token Ã© uma sequÃªncia de caracteres que representa uma informaÃ§Ã£o ou
autorizaÃ§Ã£o, geralmente usada para autenticaÃ§Ã£o ou autorizaÃ§Ã£o em sistemas.
Ele pode ser utilizado para verificar a identidade de um usuÃ¡rio ou conceder
acesso a recursos protegidos, sem a necessidade de reautenticaÃ§Ã£o constante.


JWT (JSON Web Token) Ã© um padrÃ£o aberto (RFC 7519) para a criaÃ§Ã£o de tokens de
acesso que permitem a autenticaÃ§Ã£o e a troca de informaÃ§Ãµes seguras entre
diferentes partes. Ele Ã© amplamente usado para autenticaÃ§Ã£o em APIs e aplicaÃ§Ãµes
web.

### Estrutura do JWT
O JWT Ã© composto por trÃªs partes, separadas por pontos (`.`):

1. **Header (CabeÃ§alho)** â€“ ContÃ©m o tipo do token (`JWT`) e o algoritmo de
assinatura (exemplo: `HS256` ou `RS256`).

2. **Payload (Carga Ãºtil)** â€“ ContÃ©m as informaÃ§Ãµes (claims) do usuÃ¡rio ou da
aplicaÃ§Ã£o, como ID do usuÃ¡rio, permissÃµes e tempo de expiraÃ§Ã£o.

3. **Signature (Assinatura)** â€“ Garante a integridade do token e Ã© gerada com uma
chave secreta ou chave privada, dependendo do algoritmo usado.

Exemplo de JWT codificado:
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

### Como funciona?
1. O cliente (frontend) envia credenciais para o servidor.
2. O servidor valida as credenciais e gera um JWT assinado.
3. O cliente recebe o JWT e o usa para acessar recursos protegidos.
4. O servidor valida o JWT antes de conceder acesso.

### Vantagens do JWT
- **Sem estado (Stateless)**: NÃ£o requer armazenamento no servidor (diferente de
sessÃµes).

- **Seguro**: Pode ser assinado e criptografado.

- **EscalÃ¡vel**: Ideal para arquiteturas distribuÃ­das, como microsserviÃ§os.

### Desvantagens
- **Tamanho maior**: Mais pesado que um simples token de sessÃ£o.
- **NÃ£o pode ser revogado facilmente**: A menos que seja implementado um sistema
de blacklist.

Claro! Vamos simplificar com exemplos.  

### ğŸ“Œ O que Ã© Base64?
O **Base64** Ã© uma forma de codificar dados binÃ¡rios em texto, usando um
conjunto de 64 caracteres seguros. Ele Ã© Ãºtil quando queremos transmitir dados
que podem conter caracteres especiais, como em URLs ou JSON Web Tokens
(**JWTs**).

#### ğŸ”¹ Exemplo de codificaÃ§Ã£o Base64:
Se tivermos o texto **"OlÃ¡, JWT!"**, ao codificÃ¡-lo em **Base64**, ele se torna:
```plaintext
T2zDoSwgSldUIQ==
```
Isso permite que o texto seja transmitido de forma segura sem perder informaÃ§Ãµes.

---

### ğŸ“Œ Uso do Base64 no JWT
O **JWT** tem trÃªs partes: **header**, **payload** e **signature**. As duas primeiras sÃ£o codificadas em **Base64Url**.

#### ğŸ”¹ Exemplo de um JWT:
```plaintext
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEyMywibmFtZSI6Ikpvw6NvIn0.5Vf5K5HqX-dA5zFh2cT4vJmFLR3YxkF9vxDk4i9GSaM
```
ğŸ“Œ Vamos decodificar cada parte:

1ï¸âƒ£ **Header (CabeÃ§alho)**
```plaintext
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
```
ğŸ”½ ApÃ³s decodificar de Base64:
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

2ï¸âƒ£ **Payload (Dados)**
```plaintext
eyJ1c2VySWQiOjEyMywibmFtZSI6Ikpvw6NvIn0
```
ğŸ”½ ApÃ³s decodificar de Base64:
```json
{
  "userId": 123,
  "name": "JoÃ£o"
}
```

3ï¸âƒ£ **Signature (Assinatura)**
A assinatura garante que o token nÃ£o foi alterado e nÃ£o Ã© apenas Base64, mas sim um hash seguro.

---

### ğŸ“Œ Resumo
- **Base64** transforma dados em texto seguro para transmissÃ£o.
- **No JWT**, usamos **Base64Url** para codificar **header** e **payload**.
- **A assinatura nÃ£o Ã© apenas Base64**, pois precisa ser validada com uma chave secreta.

Um texto nÃ£o codificado em **Base64** pode perder informaÃ§Ãµes quando transmitido por canais que nÃ£o suportam certos caracteres especiais. Isso acontece porque alguns sistemas e protocolos foram projetados para lidar apenas com **ASCII seguro** (como letras, nÃºmeros e poucos sÃ­mbolos).  

### ğŸ”¹ Problemas que podem ocorrer:
1ï¸âƒ£ **Caracteres especiais podem ser interpretados incorretamente**  
   - Exemplo: O caractere `"+"` pode ser tratado como espaÃ§o em algumas URLs.
   - O caractere `"/"` pode ser interpretado como um separador de diretÃ³rios.

2ï¸âƒ£ **Perda de formataÃ§Ã£o ao transmitir dados binÃ¡rios**  
   - Se um arquivo de imagem ou JSON binÃ¡rio for enviado sem codificaÃ§Ã£o, ele pode quebrar ou ser corrompido.

3ï¸âƒ£ **Incompatibilidade entre sistemas**  
   - Alguns bancos de dados e protocolos nÃ£o suportam certos caracteres diretamente.

### ğŸ”¹ Como o **Base64** resolve isso?  
O **Base64** converte os dados em um formato seguro que usa apenas **64 caracteres bem suportados** (A-Z, a-z, 0-9, "+", "/" e "="). Isso garante que a informaÃ§Ã£o seja **transmitida corretamente** sem modificaÃ§Ãµes indesejadas.  

ğŸ”¹ **Exemplo prÃ¡tico**:  
Se tentarmos enviar um JSON com acentos e caracteres especiais sem codificaÃ§Ã£o, pode haver problemas de compatibilidade.  
```json
{ "nome": "JoÃ£o & Maria" }
```
Codificando em **Base64**:
```plaintext
eyJub21lIjogIkpvw6NvICYgTWFyaWEifQ==
```
Agora ele pode ser enviado com seguranÃ§a sem risco de alteraÃ§Ã£o.

### ğŸ”¹ Resumo:
- **Sem Base64** â†’ Risco de perda de caracteres especiais.
- **Com Base64** â†’ Dados protegidos e compatÃ­veis com qualquer sistema.  

PASSPORT:

O **Passport** Ã© um middleware de autenticaÃ§Ã£o para **Node.js**, amplamente usado
com **Express.js**. Ele facilita a autenticaÃ§Ã£o de usuÃ¡rios em aplicaÃ§Ãµes web e
APIs, suportando diversos mÃ©todos de autenticaÃ§Ã£o, como **JWT, OAuth, Google,
Facebook, Local (usuÃ¡rio e senha)** e muitos outros.  

---

### ğŸ“Œ **Principais Recursos do Passport**
âœ… **Modular** â†’ Suporte a mÃºltiplas estratÃ©gias de autenticaÃ§Ã£o.  
âœ… **FlexÃ­vel** â†’ Pode ser integrado com qualquer framework Node.js.  
âœ… **SessÃµes** â†’ Suporte opcional a autenticaÃ§Ã£o baseada em sessÃ£o (usando cookies).  
âœ… **Passport Strategies** â†’ Plugins para diferentes mÃ©todos de login (Google, Facebook, JWT, etc.).

---

### ğŸ“Œ **Como Funciona?**
O **Passport** funciona atravÃ©s de **estratÃ©gias**. Cada estratÃ©gia define um
mÃ©todo de autenticaÃ§Ã£o especÃ­fico, como login com e-mail/senha ou autenticaÃ§Ã£o
via JWT.

1ï¸âƒ£ **O usuÃ¡rio faz login** (exemplo: e-mail e senha).  
2ï¸âƒ£ **O Passport verifica as credenciais** usando uma estratÃ©gia (exemplo:
`passport-jwt`).  
3ï¸âƒ£ **Se vÃ¡lido**, gera um token ou inicia uma sessÃ£o.  
4ï¸âƒ£ **Se invÃ¡lido**, retorna erro.  

---

### ğŸ“Œ **Usando Passport com JWT (API REST)**
Caso esteja desenvolvendo uma **API REST**, Ã© comum usar **`passport-jwt`** para
autenticaÃ§Ã£o via tokens JWT.  

ğŸ”¹ **Exemplo bÃ¡sico com JWT**:
```js
const JwtStrategy = require('passport-jwt').Strategy;
const ExtractJwt = require('passport-jwt').ExtractJwt;

const opts = {
  jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
  secretOrKey: 'seu_segredo_secreto'
};

passport.use(new JwtStrategy(opts, (jwtPayload, done) => {
  const user = users.find(u => u.id === jwtPayload.id);
  if (user) return done(null, user);
  return done(null, false);
}));
```
ğŸ”¹ Depois, para proteger rotas:
```js
app.get('/profile', passport.authenticate('jwt', { session: false }), (req, res) => {
  res.json({ message: 'Bem-vindo ao perfil!', user: req.user });
});
```

---

### ğŸ“Œ **Quando Usar Passport?**
âœ”ï¸ **Se sua aplicaÃ§Ã£o precisar de mÃºltiplos mÃ©todos de login** (Google, Facebook, GitHub, JWT, etc.).  
âœ”ï¸ **Se quiser facilitar a autenticaÃ§Ã£o em APIs e aplicaÃ§Ãµes web**.  
âœ”ï¸ **Se precisar de suporte a sessÃµes e cookies automaticamente**.  

Se sua aplicaÃ§Ã£o **sÃ³ usa JWT**, pode ser mais simples implementar a autenticaÃ§Ã£o
manualmente com `jsonwebtoken`, sem precisar do **Passport**.

Esse cÃ³digo configura a estratÃ©gia de autenticaÃ§Ã£o **JWT** no **Passport.js** para uma aplicaÃ§Ã£o **Node.js**. Vou explicar detalhadamente cada parte.

---

## ğŸ”¹ **ExplicaÃ§Ã£o do CÃ³digo**
```js
const passport = require('passport');
const passportJwt = require('passport-jwt');
const {Extract, Strategy} = passportJwt
```
ğŸ”¹ **O que acontece aqui?**  
- Importamos o passport
- Importamos o password-jwt
- Importamos a **estratÃ©gia JWT** do `passport-jwt`.  
- Importamos o **extrator do token** (`Extract`) para pegar o JWT da requisiÃ§Ã£o.  

---

### **1ï¸âƒ£ ConfiguraÃ§Ã£o das OpÃ§Ãµes da EstratÃ©gia**
```js
const opts = {
  jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
  secretOrKey: 'seu_segredo_secreto'
};
```
ğŸ”¹ **ExplicaÃ§Ã£o das opÃ§Ãµes (`opts`)**:  
- **`jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken()`**  
  - Diz ao Passport para extrair o token JWT do **header** `Authorization` no formato `Bearer <token>`.  
  - Exemplo de cabeÃ§alho vÃ¡lido:
    ```
    Authorization: Bearer eyJhbGciOiJIUzI1...
    ```
  
- **`secretOrKey: 'seu_segredo_secreto'`**  
  - Define a chave secreta usada para verificar a assinatura do JWT.  
  - Essa chave deve ser **a mesma usada para assinar o token no backend**.

---

### **2ï¸âƒ£ DefiniÃ§Ã£o da EstratÃ©gia JWT no Passport**
```js
passport.use(new JwtStrategy(opts, (jwtPayload, done) => {
  const user = users.find(u => u.id === jwtPayload.id);
  if (user) return done(null, user);
  return done(null, false);
}));
```
ğŸ”¹ **O que acontece aqui?**  
1ï¸âƒ£ Criamos uma **nova estratÃ©gia JWT** usando `new JwtStrategy(opts, callback)`.  
2ï¸âƒ£ O Passport verifica o JWT **automaticamente** com base nas opÃ§Ãµes (`opts`).  
3ï¸âƒ£ Se o JWT for vÃ¡lido, a funÃ§Ã£o callback Ã© chamada com `jwtPayload`.  

#### **ExplicaÃ§Ã£o do Callback `(jwtPayload, done) => {}`**
- **`jwtPayload`**: ContÃ©m os dados do usuÃ¡rio extraÃ­dos do token JWT (exemplo abaixo).
- **`done(null, user)`**: O usuÃ¡rio foi encontrado, entÃ£o o Passport retorna o usuÃ¡rio autenticado.
- **`done(null, false)`**: Se o usuÃ¡rio nÃ£o for encontrado, o acesso Ã© negado.

ğŸ”¹ **Exemplo do `jwtPayload` extraÃ­do de um JWT vÃ¡lido**:
```json
{
  "id": 123,
  "name": "JoÃ£o",
  "iat": 1700000000,
  "exp": 1700003600
}
```
- `id`: Identificador do usuÃ¡rio.
- `iat`: Data de criaÃ§Ã£o do token.
- `exp`: Data de expiraÃ§Ã£o do token.

ğŸ”¹ **Como o usuÃ¡rio Ã© buscado?**
```js
const user = users.find(u => u.id === jwtPayload.id);
```
- `users` Ã© uma lista fictÃ­cia de usuÃ¡rios cadastrados.
- Busca-se um usuÃ¡rio pelo **ID extraÃ­do do token**.

---

## ğŸ”¹ **Como Usar Essa EstratÃ©gia no Express?**
ApÃ³s configurar a estratÃ©gia, podemos usÃ¡-la para proteger rotas.

```js
const express = require('express');
const passport = require('passport');

const app = express();
app.use(passport.initialize());

// Rota protegida com JWT
app.get('/perfil', passport.authenticate('jwt', { session: false }), (req, res) => {
  res.json({ message: 'Bem-vindo ao seu perfil!', user: req.user });
});

app.listen(3000, () => console.log('Servidor rodando na porta 3000'));
```
ğŸ“Œ Aqui:
- Qualquer requisiÃ§Ã£o a `/perfil` **precisa de um token JWT vÃ¡lido**.
- Se o token for vÃ¡lido, `req.user` conterÃ¡ os dados do usuÃ¡rio.

---

## ğŸ”¹ **Resumo**
âœ” **passport-jwt** â†’ Middleware para autenticaÃ§Ã£o JWT no Passport.  
âœ” **Extrai o JWT do cabeÃ§alho** `Authorization: Bearer <token>`.  
âœ” **Verifica a assinatura do JWT** usando uma chave secreta.  
âœ” **Busca o usuÃ¡rio pelo ID do payload do JWT**.  
âœ” **Retorna o usuÃ¡rio autenticado ou rejeita a requisiÃ§Ã£o**.  

---

O **Mongoose** Ã© uma biblioteca do **Node.js** usada para interagir com o banco de dados **MongoDB**. Ele funciona como uma **ORM (Object-Relational Mapping)**, mas para bancos NoSQL, sendo mais precisamente um **ODM (Object-Document Mapping)**.  

---

## ğŸ”¹ **Por que usar o Mongoose?**
âœ” **Facilita a modelagem de dados** â†’ Permite criar **Schemas** e definir a estrutura dos documentos.  
âœ” **ValidaÃ§Ã£o de dados** â†’ Garante que os dados inseridos no banco estejam no formato correto.  
âœ” **Consultas poderosas** â†’ Fornece mÃ©todos mais intuitivos para buscas, updates e remoÃ§Ãµes.  
âœ” **Middleware e Hooks** â†’ Permite executar funÃ§Ãµes antes ou depois das operaÃ§Ãµes no banco.  

---

## ğŸ”¹ **Exemplo PrÃ¡tico com Mongoose**
### **1ï¸âƒ£ Instalando o Mongoose**
```sh
npm install mongoose
```

### **2ï¸âƒ£ Conectando ao MongoDB**
```js
const mongoose = require('mongoose');

mongoose.connect('mongodb://localhost:27017/meuBanco', {
  useNewUrlParser: true,
  useUnifiedTopology: true
})
.then(() => console.log('Conectado ao MongoDB!'))
.catch(err => console.error('Erro ao conectar:', err));
```
ğŸ“Œ Aqui, estamos conectando ao banco **"meuBanco"** no MongoDB local.

---

### **3ï¸âƒ£ Criando um Schema e Model**
```js
const usuarioSchema = new mongoose.Schema({
  nome: { type: String, required: true },
  idade: { type: Number, min: 0 },
  email: { type: String, required: true, unique: true }
});

const Usuario = mongoose.model('Usuario', usuarioSchema);
```
ğŸ“Œ **ExplicaÃ§Ã£o**:  
- Definimos um **Schema** (`usuarioSchema`) que representa a estrutura do
documento no MongoDB. 

- Criamos um **Model** (`Usuario`), que serÃ¡ usado para interagir com a coleÃ§Ã£o
no banco.

---

### **5ï¸âƒ£ Buscando UsuÃ¡rios**
```js
Usuario.find({ idade: { $gte: 18 } })
  .then(usuarios => console.log('UsuÃ¡rios adultos:', usuarios))
  .catch(err => console.error(err));
```
ğŸ“Œ Retorna todos os usuÃ¡rios com idade maior ou igual a **18**.

---

### **6ï¸âƒ£ Atualizando um Documento**
```js
Usuario.updateOne({ email: 'joao@email.com' }, { idade: 31 })
  .then(() => console.log('UsuÃ¡rio atualizado!'))
  .catch(err => console.error(err));
```
ğŸ“Œ Atualiza a **idade** do usuÃ¡rio cujo **email** Ã© `'joao@email.com'`.

---

### **7ï¸âƒ£ Removendo um Documento**
```js
Usuario.deleteOne({ email: 'joao@email.com' })
  .then(() => console.log('UsuÃ¡rio removido!'))
  .catch(err => console.error(err));
```
ğŸ“Œ Remove um usuÃ¡rio com base no **email**.

---

## ğŸ”¹ **Resumo**
âœ” **Mongoose** Ã© uma biblioteca que facilita a interaÃ§Ã£o entre **Node.js** e
**MongoDB**. 
 
âœ” Usa **Schemas** para definir a estrutura dos dados. 

âœ” Permite **validaÃ§Ãµes**, **consultas avanÃ§adas** e **middlewares**.  

âœ” Facilita operaÃ§Ãµes como **inserÃ§Ã£o, busca, atualizaÃ§Ã£o e remoÃ§Ã£o** de 
documentos.  

No MongoDB, um Model (ou modelo) Ã© uma representaÃ§Ã£o de uma coleÃ§Ã£o no banco de dados. Ele define a estrutura dos documentos, as regras de validaÃ§Ã£o e fornece mÃ©todos para interagir com os dados.

No Mongoose, um Model Ã© criado a partir de um Schema e serve como a interface principal para manipular documentos no MongoDB.

ğŸ”¹ O que um Model faz?
âœ” Define como os dados devem ser armazenados (tipos, validaÃ§Ãµes, padrÃµes).
âœ” Permite CRUD (Create, Read, Update, Delete) facilmente.
âœ” Atua como ponte entre o cÃ³digo JavaScript e o banco MongoDB.

O QUE Ã‰ CRON?

O cron Ã© um agendador de tarefas usado para executar comandos ou scripts automaticamente em horÃ¡rios programados. Ele Ã© muito utilizado em sistemas Unix/Linux para automatizar processos recorrentes, como backups, limpeza de logs e envio de e-mails.

ğŸ”¹ Como o cron Funciona?
O cron usa um arquivo chamado crontab (cron table) para armazenar as tarefas agendadas. Cada linha desse arquivo representa uma tarefa, especificando quando e o que deve ser executado.

ğŸ“Œ Sintaxe bÃ¡sica do crontab:

nginx
Copy
Edit
MINUTO HORA DIA-MÃŠS MÃŠS DIA-SEMANA COMANDO
MINUTO (0â€“59)
HORA (0â€“23)
DIA-MÃŠS (1â€“31)
MÃŠS (1â€“12)
DIA-SEMANA (0â€“6) (0 = Domingo, 6 = SÃ¡bado)
COMANDO â†’ O script ou comando a ser executado



O QUE Ã‰ O KNEX?

O Knex.js Ã© um query builder para Node.js que facilita a interaÃ§Ã£o com bancos de 
dados relacionais, como PostgreSQL, MySQL, SQLite, MariaDB, entre outros. Ele
permite escrever consultas SQL de forma programÃ¡tica usando JavaScript,
oferecendo mais flexibilidade e organizaÃ§Ã£o no cÃ³digo.

ğŸ”¹ Principais recursos do Knex.js:
CompatÃ­vel com vÃ¡rios bancos de dados relacionais.
Suporte a migrations para versionamento do banco.
ConstruÃ§Ã£o de queries dinÃ¢micas e reutilizÃ¡veis.
TransaÃ§Ãµes para garantir a integridade dos dados.
Suporte a Promises e async/await para facilitar a programaÃ§Ã£o assÃ­ncrona.

knex init - cria o arquivo de configuraÃ§Ã£o do knex

knex migrate:make create_table_users - comando para criar uma migration

O QUE SÃƒO MIGRATIONS?

Uma **migration** (ou **migraÃ§Ã£o**) Ã© um arquivo que define alteraÃ§Ãµes na
estrutura do banco de dados de forma programÃ¡tica, permitindo versionamento e
controle das mudanÃ§as ao longo do tempo.  

### ğŸ“Œ **Para que servem as migrations?**
- Criar, modificar ou excluir tabelas e colunas.

- Garantir que diferentes ambientes (desenvolvimento, teste e produÃ§Ã£o) tenham
a mesma estrutura de banco.

- Reverter mudanÃ§as facilmente em caso de erro.

- Facilitar a colaboraÃ§Ã£o entre desenvolvedores.

---

### ğŸ›  **Exemplo de migration com Knex.js**

#### 1ï¸âƒ£ **Criando uma migration**
Para gerar uma nova migration no Knex, execute:
```sh
npx knex migrate:make create_users_table
```
Isso cria um arquivo em `migrations/` com um nome parecido com:  
ğŸ“„ `20250130120000_create_users_table.js`

#### 2ï¸âƒ£ **Editando a migration**
Abra o arquivo gerado e defina as mudanÃ§as:

```js
exports.up = function(knex) {
  return knex.schema.createTable('users', function(table) {
    table.increments('id'); // Chave primÃ¡ria autoincremento
    table.string('name').notNullable();
    table.string('email').unique().notNullable();
    table.timestamp('created_at').defaultTo(knex.fn.now());
  });
};

exports.down = function(knex) {
  return knex.schema.dropTable('users');
};
```

#### 3ï¸âƒ£ **Rodando a migration**
```sh
knex migrate:latest
```

#### 4ï¸âƒ£ **Revertendo uma migration**
Se precisar desfazer a Ãºltima migraÃ§Ã£o:
```sh
knex migrate:rollback
```

---

### ğŸš€ **Resumo**
- `up`: Define como criar/modificar tabelas.
- `down`: Define como reverter as mudanÃ§as.
- `migrate:make`: Cria uma nova migration.
- `migrate:latest`: Aplica todas as migrations pendentes.
- `migrate:rollback`: Reverte a Ãºltima migration.


As migrations funcionam sobre o mesmo princÃ­pio do github, que Ã© 
de permitir o controle de versÃµes, com a particularidade do controle
versÃµes feito pelas migrations ser de banco de dados.

PARA QUE SERVEM AS TABELAS KNEX_MIGRATIONS E KNEX_LOCK_MIGRATIONS

As tabelas `knex_migrations` e `knex_migrations_lock` sÃ£o criadas automaticamente
pelo **Knex.js** para gerenciar o estado das migrations. Elas ajudam a garantir
que as migraÃ§Ãµes sejam aplicadas corretamente e sem conflitos.  

---

## ğŸ“Œ **1. Tabela `knex_migrations`**  
Essa tabela armazena um **histÃ³rico das migrations jÃ¡ executadas**.  

ğŸ”¹ **Colunas principais**:
- `id`: Identificador Ãºnico da migration.
- `name`: Nome do arquivo da migration (ex: `20250130120000_create_users_table.js`).
- `batch`: NÃºmero do lote da migration (migrations aplicadas juntas recebem o mesmo batch).
- `migration_time`: Data e hora em que a migration foi aplicada.

ğŸ”¹ **Exemplo de conteÃºdo**:

| id | name                                | batch | migration_time        |
|----|-------------------------------------|-------|-----------------------|
| 1  | 20250130120000_create_users_table  | 1     | 2025-01-30 12:00:00   |
| 2  | 20250130123000_add_email_to_users  | 2     | 2025-01-30 12:30:00   |

### **Como o Knex usa essa tabela?**
- Antes de rodar uma migration, o Knex verifica se ela jÃ¡ foi executada.
- Se jÃ¡ estiver listada, ele **pula** essa migration para evitar duplicaÃ§Ãµes.
- Se precisar **reverter** (`knex migrate:rollback`), ele remove a Ãºltima batch
de migrations.

---

## ğŸ“Œ **2. Tabela `knex_migrations_lock`**  
Essa tabela serve para **evitar que duas instÃ¢ncias do Knex rodem migrations ao
mesmo tempo**, o que poderia causar inconsistÃªncias.  

ğŸ”¹ **Colunas principais**:
- `is_locked`: Indica se hÃ¡ um processo de migration em andamento.  
  - `0`: Nenhum processo ativo (liberado para rodar migrations).
  - `1`: Migration em andamento (impede execuÃ§Ãµes simultÃ¢neas).  

ğŸ”¹ **Exemplo de conteÃºdo**:

| is_locked |
|-----------|
| 0         |

### **Quando isso Ã© Ãºtil?**
- Em ambientes de produÃ§Ã£o, se duas instÃ¢ncias do Node tentarem rodar `knex
migrate:latest` ao mesmo tempo, isso poderia corromper o banco. O lock impede
esse problema.

- Se houver uma falha durante a execuÃ§Ã£o de migrations e a flag `is_locked` nÃ£o
for resetada, pode ser necessÃ¡rio **resetar manualmente**:

```sh
UPDATE knex_migrations_lock SET is_locked = 0;
```

---

## ğŸš€ **Resumo**
| Tabela                   | FunÃ§Ã£o |
|--------------------------|------------------------------------------------|
| **knex_migrations**      | Registra quais migrations jÃ¡ foram aplicadas. |
| **knex_migrations_lock** | Evita que mÃºltiplos processos rodem migrations ao mesmo tempo. |



